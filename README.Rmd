---
title: "Polling Station Level Election Data for the 2018 General Elections in Pakistan"
author: "Luke Sonnet"
output: md_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r, results='hide', eval=F, echo=F}
library(haven)
library(tidyverse)
f28n <- read_dta("source_data/rcons_data/Form_28_NA_List.dta")
f28p <- read_dta("source_data/rcons_data/Form_28_PROVINCIAL_List.dta")
f45 <- read_dta("source_data/rcons_data/Form_45_Male_Female_Turnout.dta")
f48 <- read_dta("source_data/rcons_data/Form_48_ResultForm.dta")
f49 <- read_dta("source_data/rcons_data/Form_49_Candidate_List.dta")
```

## Polling station level electoral returns

These data are the official form 48s (polling station level returns by candidate) and the unofficial form 45s, from which we collect preliminary gender-based turnout. This should allow for analysis of gender-based turnout, even in combined polling stations. Note the form 45s uploaded by the ECP were not the final, official forms for the ratification of the election. Only the form 48s, which do not have gendered turnout, are considered official.

Note that the release of these forms was *not* complete. Thus there is not complete coverage, and in some case the sum of the polling station totals is quite different from the reported constituency level returns. Furthermore, for some polling stations we only have form 45 data and for other polling stations we have only form 48 data (there are many missing form 45s).

For most of the numeric variables there are three kinds of missing data:
- `NA`, or missing data: In this case the source of the missingness is one of two things. For the `can_votes_*` variables these are NA if there was no candidate for whom votes could be entered. For example, if a polling station only had 20 candidates, then `can_votes_21` would be NA. Another source of NAs is when merging with the form 45 data. Form 48 fields will be NA if the polling station only exists in the Form 45 data, and the same is true in reverse.
- `-99`: Data entry operator could not read the field, but it existed
- `-88`: Data missing on hard copy form

In some cases, some of the data differs across the two datasets. For that reason, and to clearly denote which form has which data, we append `_45` to data from the form 45s.

```{r, results='hide', echo=FALSE, eval=FALSE}
# Form 28 data
f28 <- bind_rows(
  f28n %>% mutate(assembly = "National"), 
  f28p %>% 
    mutate(assembly = "Provincial") %>%
    select(-assembly_type)
) %>%
  mutate(
    constituency_ps_id = paste0(constituency_id, "_", ps_id),
    block_code_type = case_when(
      block_code_rural %in% c("0", "") & !(block_code_urban %in% c("0", "")) ~ "Urban",
      !(block_code_rural %in% c("0", "")) & block_code_urban %in% c("0", "") ~ "Rural",
      TRUE ~ "Unclear"
    ),
    block_code = ifelse(block_code == "0", NA, block_code),
    # Fix obvious typos in inconsistent polling station names
    ps_name_from_form28 = case_when(
      constituency_ps_id == "PB17_10" & ps_name == "(2) LIBRARY HALL MACH (MALE)" ~ "LIBRARY HALL MACH (MALE)",
      constituency_ps_id %in% c("PB17_28", "PB17_29") & ps_name == "GOVT BOYS HIGH SCHOOL RIND ALI (MALE)" ~ "2 GOVT HIGH SCHOOL RIND ALI MALE",
      constituency_ps_id == "PB17_62" & ps_name == "BOYS P/S KHARA COMBINED" ~ "BOYS H/S BHERI COMBINED",
      TRUE ~ ps_name
    ),
    # Note: there remain some inconsistencies that it is unclear how to solve
    # When possible, prefer PS names from ps data
    
    # Create unique code
    constituency_ps_id_block_code = paste0(constituency_ps_id, "_", block_code),
    
    # Fix female and male NAs when it's very likely they should be 0
    female_voters = case_when(
      is.na(female_voters) & male_voters > 0 & male_booths > 0 & female_booths == 0 ~ 0,
      TRUE ~ female_voters
    ),
    male_voters = case_when(
      is.na(male_voters) & female_voters > 0 & female_booths > 0 & male_booths == 0 ~ 0,
      TRUE ~ female_voters
    ),
    # Fix unnecessary errors in total_voters and make safe assumptions about when
    # Female and male voters are missing and total should be present
    total_voters = case_when(
      is.na(total_voters) & male_voters >= 0  & female_voters >= 0 ~ male_voters + female_voters,
      total_voters == 0 & is.na(male_voters) & is.na(female_voters) ~ NA_real_,
      TRUE ~ total_voters
    )
  ) %>%
  rename(voter_serials_assigned_to_station = no_voters_on_ea) %>%
  # mutate_at(
  #   vars(ends_with("_booths"), ends_with("_voters")),
  #   list(
  #     ~case_when(
  #       is.na(.) ~ -88,
  #       . == -77 ~ -88,
  #       TRUE ~ .
  #     )
  #   )
  # ) %>%
  select(constituency_ps_id_block_code, constituency_ps_id, province, assembly, constituency_id, constituency_area, ps_id,
         ps_name_from_form28, block_code, block_code_type, name_ea_rural, name_ea_urban, everything()) %>%
  select(-block_code_rural, -block_code_urban, -constituency_no_NA, -constituency_area_NA, -ps_id_NA, -ps_name)

# Demonstrate that booths are not always fixed within constituency
ps_booths <- f28 %>% 
  group_by(constituency_ps_id) %>%
  summarize_at(vars(ends_with("_booths")), list(~length(unique(.)))) %>%
  filter_at(vars(ends_with("_booths")), any_vars(. != 1))

# Some inconsistent names within constituency_ps_id
ps_names <- f28 %>% 
  group_by(constituency_ps_id) %>%
  summarize(n_ps_names = length(unique(ps_name_from_form28))) %>%
  filter(n_ps_names != 1)
f28 %>% 
  left_join(ps_names) %>%
  filter(!is.na(n_ps_names)) %>%
  select(constituency_ps_id, ps_name_from_form28, name_ea_rural, name_ea_urban) %>%
  as.data.frame

# Check values on voters and booths
f28 %>%
  filter_at(vars(ends_with("voters"), ends_with("booths")), any_vars(. < 0 | is.na(.))) %>%
  head() %>% as.data.frame
filter(f28, is.na(female_booths)) %>% as.data.frame

table(f28$male_booths, f28$female_booths, useNA = "a")
table(f28$total_booths, useNA = "a")

f28 %>%
  mutate_at(vars(ends_with("voters")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(male_voters, female_voters, total_voters, useNA = "a"))

f28 %>%
  filter(total_voters == 0, male_voters > 0 | is.na(female_voters)) %>%
  as.data.frame()

f28 %>%
  filter(total_voters > 0, male_voters == 0, female_voters == 0) %>%
  as.data.frame()

f28 %>%
  filter(total_voters < 0 | is.na(total_voters)) %>%
  as.data.frame()

glimpse(f28)

# constituency codes with dashes
table(f28$block_code[as.numeric(f28$block_code) <= 0 | is.na(as.numeric(f28$block_code))], useNA = 'a')
filter(f28, block_code == "332030401-06") %>% as.data.frame
filter(f28, block_code == "332030402")

# All unique names
table(duplicated(f28$constituency_ps_id_block_code))

write_csv(f28, path = "data/electoral_area_ps_data.csv")

f28_ps_level <- f28 %>%
  group_by(constituency_ps_id) %>%
  summarize_at(vars(ends_with("_voters")), list(~sum(ifelse(. < 0, NA, .), na.rm = TRUE)))

# Polling station returns
f48_clean <- f48 %>%
  mutate(
    constituency_ps_id = paste0(constituency_id, "_", ps_id),
    assembly = ifelse(grepl("^NA", constituency_id), "National", "Provincial"),
    # There are 62 cases in which total_votes is missing
    # but both valid_votes and invalid_votes exist
    # In those cases we can just impute total votes
    total_votes = case_when(
      total_votes < 0 & valid_votes >= 0 & invalid_votes >= 0 ~ valid_votes + invalid_votes,
      TRUE ~ total_votes
    ),
    # Similarly other cases where the total and one of the other
    # numbers is known, and we can fill in the third
    valid_votes = case_when(
      valid_votes < 0 & total_votes >= 0 & invalid_votes >= 0 ~ total_votes - invalid_votes,
      TRUE ~ valid_votes
    ),
    # There are two cases where total_votes is less than valid votes and invalid is missing
    # This is clearly a mistake
    invalid_votes = case_when(
      invalid_votes < 0 & total_votes >= 0 & valid_votes >= 0 & total_votes - valid_votes > 0 ~ total_votes - valid_votes,
      TRUE ~ invalid_votes
    ),
    # Fix a typo
    can_votes_11 = ifelse(constituency_ps_id == "NA79_50", can_votes_12, can_votes_11),
    can_votes_12 = ifelse(constituency_ps_id == "NA79_50", can_votes_13, can_votes_12),
    can_votes_13 = ifelse(constituency_ps_id == "NA79_50", can_votes_14, can_votes_13),
    can_votes_14 = ifelse(constituency_ps_id == "NA79_50", can_votes_15, can_votes_14),
    can_votes_15 = ifelse(constituency_ps_id == "NA79_50", NA, can_votes_15),
  ) %>%
  select(-assembly_type)

# Check vote totals data
f48 %>%
  mutate_at(vars(ends_with("votes")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(valid_votes, invalid_votes, total_votes, useNA = "a"))

with(
  filter(f48, valid_votes >=  0 & invalid_votes >= 0),
  table(valid_votes + invalid_votes == total_votes)
)
with(
  filter(f48_clean, valid_votes >=  0 & invalid_votes >= 0),
  table(valid_votes + invalid_votes == total_votes)
)
f48_clean %>%
  mutate_at(vars(ends_with("votes")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(valid_votes, invalid_votes, total_votes, useNA = "a"))

# Check constituency data
names(f48_clean)
f48_clean %>%
  mutate_at(vars(starts_with("registered")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(registered_voters_male, registered_voters_female, registered_voters_total, useNA = "a"))

f48_clean %>%
  mutate_at(vars(starts_with("total_number")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(total_number_ps_female, total_number_ps_combined, total_number_ps_total, useNA = "a"))

table(duplicated(f48_clean$constituency_ps_id))
f48_long <- f48_clean %>%
  select(constituency_id, constituency_ps_id, invalid_votes, valid_votes, total_votes, starts_with("can_")) %>%
  gather(key, value, starts_with("can_")) %>%
  mutate(key = gsub("can_", "", key)) %>%
  separate(key, into = c("variable", "candidate_id")) %>%
  spread(variable, value) 


f48_merged_f49 <- f48_long %>%
  filter(!(is.na(votes) & name == "")) %>%
  mutate(
    candidate_id = as.numeric(candidate_id),
    votes = as.numeric(votes),
    votes = case_when(
      is.na(votes) ~ -88,
      TRUE ~ votes
    )
  ) %>%
  left_join(
    f49 %>%
      mutate(valid_votes_polled = as.numeric(gsub("\\*", "", valid_votes_polled))) %>%
      select(constituency_id, candidate_id, party_affiliation, valid_votes_polled, comments)
  )

f48_long_clean <- f48_merged_f49 %>%
  group_by(constituency_ps_id) %>%
  mutate(
    ps_valid_votes_summed = sum(ifelse(votes < 0, NA, votes)),
    n_candidates = max(candidate_id)
  ) %>%
  group_by(constituency_id, candidate_id) %>%
  mutate(
    candidate_valid_votes_summed = sum(ifelse(votes < 0, NA, votes)),
    candidate_valid_share = case_when(
      votes < 0 | valid_votes < 0 ~ NA_real_,
      TRUE ~ votes / valid_votes
    ),
    candidate_valid_share_of_summed = case_when(
      votes < 0 | ps_valid_votes_summed < 0 ~ NA_real_,
      TRUE ~ votes / ps_valid_votes_summed
    )
  ) %>%
  rename(
    candidate_votes = votes,
    candidate_name = name,
    candidate_party = party_affiliation
  )
f48_wide_w_long_vars <- f48_long_clean %>%
  group_by(constituency_ps_id) %>%
  summarize_at(vars(n_candidates, ps_valid_votes_summed), unique)
# Don't use sum candidate votes because many missing polling stations!

names(f48_long_clean)
f48_wide_merge_from_long <- f48_long_clean %>%
  ungroup() %>%
  select(candidate_name, candidate_id, candidate_votes, candidate_party, candidate_valid_share, constituency_ps_id) %>%
  gather(
    key, val,
    candidate_name, candidate_votes, candidate_party, candidate_valid_share
  ) %>%
  mutate(
    key = paste0(gsub("_copy", "", key), "_", as.character(candidate_id))
  ) %>%
  select(-candidate_id) %>%
  spread(key, val) %>%
  mutate_at(vars(starts_with("candidate_votes"), starts_with("candidate_valid_share")), as.numeric)

# clean f45 data
f45_clean <- f45 %>%
  mutate(
    constituency_ps_id = paste0(constituency_id, "_", ps_id)
  ) %>%
  select(-assembly_type)

f45_merge <- f45_clean %>% 
  select(-constituency_id, -ps_id) %>%
  mutate(
    total_turnout = case_when(
      total_votes >= 0 & !is.na(total_votes) & (total_turnout < 0 | is.na(total_turnout)) ~ total_votes,
      TRUE ~ total_turnout
    )
  ) %>%
  rename_at(vars(-constituency_ps_id), list(~paste0(., "_45"))) %>%
  mutate_at(vars(contains("turnout_45")), list(~ifelse(. == -77, -88, .))) %>%
  select(-total_votes_45) %>%
  rename_at(vars(ends_with("turnout_45")), list(~gsub("turnout", "votes", .)))

f45_merge %>%
  mutate_at(vars(ends_with("votes_45")), list(~case_when(. > 0 ~ 1, TRUE ~ .))) %>%
  with(., table(total_female_votes_45, total_male_votes_45,total_votes_45, useNA = "a"))

# Create final wide data
f48_wide_ready <- f48_clean %>% 
  select(-starts_with("can")) %>%
  left_join(f48_wide_merge_from_long) %>%
  left_join(f45_merge) %>%
  left_join(f28_ps_level) %>%
  left_join(f48_wide_w_long_vars) %>%
  rename_at(
    vars(starts_with("total_number_ps")),
    list(~gsub("^total", "constituency", .))
  ) %>%
  rename_at(
    vars(starts_with("registered_")),
    list(~paste0("constituency_", .))
  ) %>%
  rename(constituency_id_NA = constituency_no_NA) %>%
  mutate(turnout = total_votes / total_voters,
         turnout_45 = total_votes_45 / total_voters,
         male_turnout_45 = total_male_votes_45 / male_voters,
         female_turnout_45 = total_female_votes_45 / female_voters) %>%
  select(constituency_ps_id, province, assembly, constituency_id, constituency_name, constituency_id_NA, ps_id, ps_name, 
         starts_with('constituency_number'), starts_with("constituency_registered_voters"), n_candidates,
         male_voters, female_voters, total_voters,
         valid_votes, invalid_votes, total_votes, turnout,
         ps_valid_votes_summed,
         total_male_votes_45, total_female_votes_45, total_votes_45,
         male_turnout_45, female_turnout_45, turnout_45,
         everything()) %>%
  select(-province_45)

write_csv(f48_long_clean, path = "data/ps_data_long.csv")
write_csv(f48_wide_ready, path = "data/ps_data_wide.csv")

# Many missing f45s
length(setdiff(f48_clean$constituency_ps_id, f45_clean$constituency_ps_id))
# Few missing f48s (for which f45s exist)
length(setdiff(f45_clean$constituency_ps_id, f48_clean$constituency_ps_id))

intersect(names(f48_clean), names(f45_clean))

# Old Sanity checks
sanity_check <- full_join(
  f48_clean, 
  f45_clean,
  by = "constituency_ps_id"
)
table(sanity_check$province.x == sanity_check$province.y)
table(sanity_check$ps_name.x == sanity_check$ps_name.y)
table(sanity_check$total_votes.x == sanity_check$total_votes.y)


table(f45_clean$constituency_id)
```

### Wide data variables

You can get the wide polling station level data in [data/ps_data_wide.csv](data/ps_data_wide.csv).

* constituency_ps_id: the pasted together constituency_id and ps_id, a unique identifier of the constituency-polling station
* province
* assembly
* constituency_id
* constituency_name
* constituency_id_NA: the corresponding national assembly constituency (for the provincial assemblies)
* ps_id: the official serial number of the polling station
* ps_name: the name of the polling station

Some constituency level electoral data:

* constituency_registered_voters_male
* constituency_registered_voters_female
* constituency_registered_voters_total
* constituency_number_ps_male: number of male-only polling stations in the constituency
* constituency_number_ps_female: number of female-only polling stations in the constituency
* constituency_number_ps_combined: number of combined polling stations in the constituency
* constituency_number_ps_total: total number of polling stations in the constituency
* n_candidates: the number of candidate registered in this constituency

Polling station level voting data:

* male_voters, female_voters, total_voters: the total number of registered voters, merged from the form 28 polling station-electoral area data
* invalid_votes, valid_votes, total_votes: the votes cast by category as recorded on the form 48s
* turnout: `total_votes / total_voters`, the turnout comparing the registered voters on the form 28s to the number of votes on the form 48s
* ps_valid_votes_summed: in most cases should be the same as `valid_votes`, but this comes from summing across the candidate votes (where none of them are missing), which in some cases is different from `valid_votes` where there are gaps in entry.
* total_male_votes_45, total_female_votes_45, total_votes_45: total votes cast by gender from the form 45s; these are unofficial forms and may differ when summed from the `total_votes` column.
* male_turnout_45, female_turnout_45, turnout_45: turnout as defined by the gendered vote totals over the form 28 number of registered voters of that gender (e.g. `total_female_votes_45 / male_voters`)

Candidate level names, vote totals, parties, and vote share:

The asterices represent which candidate id (in the long version of the data) we are referring to, and links the columns together.

* candidate_name_*
* candidate_votes_*
* candidate_party_*
* candidate_valid_share_*: This is defined as the candidate_votes over the `valid_votes` as found on the form 48s. Note there are some implausible outliers due to erroneous `valid_votes` totals.

Other:

* ps_name_45: preserved for the few mismatches in names across forms
* comments, comments_45: comments by data entry operators about the data quality and matches across fields

TODO guess PS type (female, male, combined)

### Long data variables

[data/ps_data_long.csv](data/ps_data_long.csv)

TODO document

## Electoral area data (Form 28s)

[data/electoral_area_ps_data.csv](data/electoral_area_ps_data.csv)

Each row in this data is unique to the combination of constituency, polling station, and census block, and was released by the Electoral Commission of Pakistan as Form 28.

Some polling station areas include several census blocks, and several census blocks are across several polling stations. The mapping of polling station to census block is many-to-many; this means that the same polling Furthermore, female and male only polling stations can have different mappings from polling station to census block.

The ECP released Form 28s separately for the National and Provincial Assembly constituencies. While the delimitation of polling station areas should be identical for the two constituencies, in the data they are not. We report both of them here stacked together.

Variables:

* constituency_ps_id: *used to merge with PS level data*; the pasted together constituency_id and ps_id, a unique identifier of the constituency-polling station
* constituency_ps_id_block_code: The above pasted with the block_code to generate a unique identifier for each polling station-census block code.
* province
* assembly
* constituency_id
* constituency_area
* ps_id: the official serial number of the polling station
* ps_name_from_form28: the name of the polling station; not always consistent within `constituency_ps_id`, and may not match the `ps_name` from the polling station data
* block_code: the census block code; note, there are some `block_code` values that have dashes in them. These seem to represent more than one census block code (e.g. "332030301-06-07" seems to represent "332030301", "332030306", and "332030307"). Unfortunately this is how the census blocks were reported and we are unable to figure out which voters correspond to which of the census blocks. If you need help creating a full linking between polling stations and each of these block codes, please leave a message.
* block_code_type: "Urban", "Rural", or "Unknown"
* name_ea_rural: the name of the "rural" electoral area covered by this polling station-census block
* name_ea_rural: the name of the "urban" electoral area covered by this polling station-census block
* voter_serials_assigned_to_station: sometimes, the serial number range of the voters covered in this EA (per polling station) are reported. They are repeated here verbatim from the forms.
* male_voters: the number of registered male voters in this polling station-census block
* female_voters: the number of registered female voters in this polling station-census block
* total_voters: the number of registered voters in this polling station-census block
* male_booths: the number of assigned male booths for this polling station (Note: some errors seem to show different booths within polling station id in this dataset)
* female_booths: the number of assigned female booths for this polling station (Note: some errors seem to show different booths within polling station id in this dataset)
* total_booths: the total number of assigned booths for this polling station (Note: some errors seem to show different booths within polling station id in this dataset)
